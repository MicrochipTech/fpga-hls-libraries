// ©2024 Microchip Technology Inc. and its subsidiaries
//
// Subject to your compliance with these terms, you may use this Microchip
// software and any derivatives exclusively with Microchip products. You are
// responsible for complying with third party license terms applicable to your
// use of third party software (including open source software) that may
// accompany this Microchip software. SOFTWARE IS “AS IS.” NO WARRANTIES,
// WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY
// IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT,
// SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE
// OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
// MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
// TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP’S TOTAL LIABILITY ON ALL
// CLAIMS LATED TO THE SOFTWARE WILL NOT EXCEED AMOUNT OF FEES, IF ANY, YOU PAID
// DIRECTLY TO MICROCHIP FOR THIS SOFTWARE. MICROCHIP OFFERS NO SUPPORT FOR THE
// SOFTWARE. YOU MAY CONTACT MICROCHIP AT
// https://www.microchip.com/en-us/support-and-training/design-help/client-support-services
// TO INQUIRE ABOUT SUPPORT SERVICES AND APPLICABLE FEES, IF AVAILABLE.

#pragma once

#include <type_traits>

#include "../common/common.hpp"
#include "../common/utils.hpp"
#include "hls/ap_fixpt.hpp"
#include "../../utils/generators/generated_tables/gamma_correction_table.hpp"
#include <cmath>

namespace hls {
namespace vision {

/***
 * @function GammaCorrection
 * A camera sensor provides a proportional linear relationship between light 
 * intensity and the digital value. However, a human eye perceives the images 
 * as a logarithmic function of intensity instead of a linear function. 
 * To compensate for this pixels can go through a gamma correction process by
 * using the following equation:
 * 
 *  $$ PixelOut = PixelIn^(1/GammaFactor) $$
 * 
 * The GammaCorrection function is implemented using a look-up table for exponent 
 * function. The width of the input data determines the number of entries in the 
 * table. For example, 8-bit input data would require 2^8 (256) entries. 
 * 
 * Currently, the table is pre-computed to a gamma factor of 0.5. The table is
 * generated by this file:
 * 
 * vision/utils/generators/gen_gamma_correction_table.cpp
 * 
 * To compile a different table with a different gamma value, modify the constants
 * in the file and recompile as follows:
 * 
 * cd vision/utils/generators
 * make gen_gamma_correction_table
 * 
 * The generated table will be in the following file:
 * 
 * vision/utils/generators/generated_tables/gamma_correction_table.hpp
 * 

 * @template {PixelType} Type of the pixel, e.g. HLS_8UC1
 * @template {unsigned H} Height of the image
 * @template {unsigned H} Width of the image
 * @template {StorageType STORAGE_IN} Type of storage for the input image
 * @template {StorageType STORAGE_OUT} Type of storage for the output image
 * @template {NumPixelsPerCycle NPPC} Number of pixels per cycle. This must be 
 *      divisible by the width of the image. 
 * 
 * @param {vision::Img InImg} Input image.
 * @param {vision::Img OutImg} Output image.
 * @param {ap_uint<1> enable} A value of enable = 1 (default) will actually 
 *      perform the transformation. When enable = 0, the pixels are just 
 *      forwarded from the input without change. 
 *
 * @example
 * hls::vision::GammaCorrection(ImgIn, ImgOut);
 * 
 */
template <
    PixelType PIXEL_T,
    unsigned H,
    unsigned W,
    StorageType STORAGE_IN,
    StorageType STORAGE_OUT,
    NumPixelsPerCycle NPPC>
void GammaCorrection(
    vision::Img<PIXEL_T, H, W, STORAGE_IN, NPPC> &InImg,
    vision::Img<PIXEL_T, H, W, STORAGE_OUT, NPPC> &OutImg,
    const ap_uint<1> enable = 1) {
    #pragma HLS memory partition argument(InImg) type(struct_fields)
    #pragma HLS memory partition argument(OutImg) type(struct_fields)

    static_assert(W % NPPC == 0,
        "Gamma Correction: The width of the frame must be divisible by NPPC");

    static_assert(DT<PIXEL_T, NPPC>::PerChannelPixelWidth == 8,
        "GammaCorrection only supports ChannelWidth = 8");

    using PixelWordT = typename DT<PIXEL_T, NPPC>::T;
    const unsigned ChannelWidth = DT<PIXEL_T, NPPC>::PerChannelPixelWidth;
    const unsigned PixelWidth = DT<PIXEL_T, NPPC>::W / NPPC;
    const unsigned NumChannels = DT<PIXEL_T, NPPC>::NumChannels;
    const unsigned NumPixelWords = InImg.get_height() * InImg.get_width() / NPPC;

    OutImg.set_height(InImg.get_height());
    OutImg.set_width(InImg.get_width());

    TransformPixel_enable(InImg, OutImg, enable, [](ap_uint<DT<PIXEL_T, NPPC>::W / NPPC> in){
        decltype(in) out;

        #pragma HLS loop unroll
        for(int c=0; c<NumChannels; c++) {
            out.byte(c, ChannelWidth) = GAMMA_CORRECTION_TABLE[in.byte(c,ChannelWidth)]; 
        }
        return out;
    });
}


} // End of namespace vision.
} // End of namespace hls.

